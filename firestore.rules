/**
 * @description This ruleset enforces a multi-tenant security model based on company membership and roles.
 *              Users are associated with a single company and have a defined role within that company (viewer, editor, or admin).
 *              Access to company-specific data (clients, origins, orders, etc.) is controlled by these roles.
 * @dataStructure Data is organized hierarchically under the `/companies/{companyId}` path.
 *                User profiles are stored in the `/users/{userId}` collection.  Each user document contains their `companyId` and `role`.
 * @keySecurityDecisions
 *   - Users can only read their own profile. User listing is disabled.
 *   - Company documents can only be read by members with at least "viewer" role and only modified by "admins".
 *   - Subcollections under `/companies/{companyId}` inherit company membership and role requirements.
 *   - A catch-all rule is implemented for subcollections under `/companies/{companyId}` to provide a baseline level of security without schema validation.
 * @denormalization User's `companyId` and `role` are stored directly in the `/users/{userId}` document to avoid costly `get()` calls in rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------- Utils --------
    function isSignedIn() { return request.auth != null; }

    function userDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    function userCompanyId() {
      return isSignedIn() ? userDoc().data.companyId : null;
    }

    function userRole() {
      return isSignedIn() ? userDoc().data.role : null;
    }

    function isViewer() { return isSignedIn() && (userRole() == "viewer" || userRole() == "editor" || userRole() == "admin"); }
    function isEditor() { return isSignedIn() && (userRole() == "editor" || userRole() == "admin"); }
    function isAdmin()  { return isSignedIn() && (userRole() == "admin"); }

    function isCompanyMember(companyId) {
      return isSignedIn() && userCompanyId() == companyId;
    }

    // -------- USERS (/users/{uid}) --------
    /**
     * @description Allows a user to read, create, update, and delete their own profile.
     * @path /users/{userId}
     * @allow (get) User with UID "user123" reading /users/user123
     * @allow (create) User with UID "user123" creating /users/user123
     * @deny (get) User with UID "user123" reading /users/otherUser
     * @deny (list) Any user trying to list users.
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && request.auth.uid == userId;
      allow list: if false;

      function baseUserValid() {
        return request.resource.data.keys().hasAll(["companyId", "role"]) &&
               request.resource.data.companyId is string &&
               request.resource.data.companyId.size() > 0 &&
               request.resource.data.role in ["viewer", "editor", "admin"];
      }

      allow create: if isSignedIn() && request.auth.uid == userId && baseUserValid();
      allow update: if isSignedIn() && request.auth.uid == userId && resource != null && baseUserValid();
      allow delete: if isSignedIn() && request.auth.uid == userId && resource != null;
    }

    // -------- COMPANIES (doc raiz) --------
    /**
     * @description Controls access to company documents.
     * @path /companies/{companyId}
     * @allow (get) User with companyId "company1" and role "viewer" reading /companies/company1
     * @allow (create) User with companyId "company1" and role "admin" creating /companies/company1
     * @deny (get) User with companyId "company2" and role "viewer" reading /companies/company1
     * @deny (list) Any user attempting to list companies.
     * @principle Enforces company-based access control.
     */
    match /companies/{companyId} {
      // leitura do doc da company: membros (viewer+)
      allow get: if isCompanyMember(companyId) && isViewer();
      // nunca listar companies
      allow list: if false;
      // escrever company só admin
      allow create, update, delete: if isCompanyMember(companyId) && isAdmin();
    }

    // -------- Subcoleções específicas com validação (exemplos) --------
    /**
     * @description Controls access to client documents within a company.
     * @path /companies/{companyId}/clients/{clientId}
     * @allow (get) User with companyId "company1" and role "viewer" reading /companies/company1/clients/client1
     * @allow (list) User with companyId "company1" and role "viewer" listing /companies/company1/clients
     * @allow (create) User with companyId "company1" and role "editor" creating /companies/company1/clients/client1
     * @deny (get) User with companyId "company2" and role "viewer" reading /companies/company1/clients/client1
     * @principle Enforces company membership and role-based access for client data.
     */
    match /companies/{companyId}/clients/{clientId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor() && validClient();

      function validClient() {
        return request.resource.data.name is string &&
               request.resource.data.name.size() > 0 &&
               (!("phone" in request.resource.data) || request.resource.data.phone is string) &&
               (!("email" in request.resource.data) || request.resource.data.email is string) &&
               (!("createdAt" in request.resource.data) || request.resource.data.createdAt is timestamp) &&
               (!("updatedAt" in request.resource.data) || request.resource.data.updatedAt is timestamp);
      }
    }

    /**
     * @description Controls access to origin documents within a company.
     * @path /companies/{companyId}/origins/{originId}
     * @allow (get) User with companyId "company1" and role "viewer" reading /companies/company1/origins/origin1
     * @allow (list) User with companyId "company1" and role "viewer" listing /companies/company1/origins
     * @allow (create) User with companyId "company1" and role "editor" creating /companies/company1/origins/origin1
     * @deny (get) User with companyId "company2" and role "viewer" reading /companies/company1/origins/origin1
     * @principle Enforces company membership and role-based access for origin data.
     */
    match /companies/{companyId}/origins/{originId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor() && validOrigin();

      function validOrigin() {
        return request.resource.data.name is string &&
               request.resource.data.name.size() > 0 &&
               (!("description" in request.resource.data) || request.resource.data.description is string) &&
               (!("active" in request.resource.data) || request.resource.data.active is bool) &&
               (!("createdAt" in request.resource.data) || request.resource.data.createdAt is timestamp) &&
               (!("updatedAt" in request.resource.data) || request.resource.data.updatedAt is timestamp);
      }
    }

    /**
     * @description Controls access to order documents within a company.
     * @path /companies/{companyId}/orders/{orderId}
     * @allow (get) User with companyId "company1" and role "viewer" reading /companies/company1/orders/order1
     * @allow (list) User with companyId "company1" and role "viewer" listing /companies/company1/orders
     * @allow (create) User with companyId "company1" and role "editor" creating /companies/company1/orders/order1
     * @deny (get) User with companyId "company2" and role "viewer" reading /companies/company1/orders/order1
     * @principle Enforces company membership and role-based access for order data.
     */
    match /companies/{companyId}/orders/{orderId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor() && validOrder();

      function validOrder() {
        return
          request.resource.data.keys().hasAll(["status", "total", "items"]) &&
          request.resource.data.status in ["pending", "approved", "paid", "canceled", "delivered"] &&
          request.resource.data.total is number &&
          request.resource.data.total >= 0 &&
          request.resource.data.items is list &&
          (!("customerId" in request.resource.data) || request.resource.data.customerId is string) &&
          (!("createdAt" in request.resource.data) || request.resource.data.createdAt is timestamp) &&
          (!("updatedAt" in request.resource.data) || request.resource.data.updatedAt is timestamp);
      }
    }

    /**
     * @description Provides a catch-all rule for any other subcollection under /companies/{companyId}.
     *              This maintains company membership and role security without enforcing specific schema validation.
     * @path /companies/{companyId}/{anySubcoll}/{docId}
     * @allow (get) User with companyId "company1" and role "viewer" reading /companies/company1/products/product1
     * @allow (list) User with companyId "company1" and role "viewer" listing /companies/company1/products
     * @allow (create) User with companyId "company1" and role "editor" creating /companies/company1/products/product1
     * @deny (get) User with companyId "company2" and role "viewer" reading /companies/company1/products/product1
     * @principle Enforces company membership and role-based access for all company subcollections.
     */
    match /companies/{companyId}/{anySubcoll}/{docId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor();
    }

      /**
     * @description Controls access to address documents within a company and client.
     * @path /companies/{companyId}/clients/{clientId}/addresses/{addressId}
     * @allow (get) User with companyId "company1" and role "viewer" reading /companies/company1/clients/client1/addresses/address1
     * @allow (list) User with companyId "company1" and role "viewer" listing /companies/company1/clients/client1/addresses
     * @allow (create) User with companyId "company1" and role "editor" creating /companies/company1/clients/client1/addresses/address1
     * @deny (get) User with companyId "company2" and role "viewer" reading /companies/company1/clients/client1/addresses/address1
     * @principle Enforces company membership and role-based access for client address data.
     */
    match /companies/{companyId}/clients/{clientId}/addresses/{addressId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor();
    }


    // -------- Bloqueio padrão --------
    /**
     * @description Default rule that blocks all read and write access to any document not explicitly matched by other rules.
     * @path /{document=**}
     * @deny (get) Any user trying to access any unmatched document.
     * @deny (write) Any user trying to write to any unmatched document.
     * @principle Default-deny security posture.  All access must be explicitly allowed.
     */
    match /{document=**} {
      allow read, write: if false;
    }
  }
}