/**
 * @fileoverview Firestore Security Rules for Transport App
 *
 * Core Philosophy:
 * This ruleset implements a multi-tenant security model where data is segregated by company.
 * Users are associated with a single company and have roles (viewer, editor, admin) within that company.
 * Access to company-specific data (clients, origins, orders) is controlled based on the user's company membership and role.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information, including companyId and role.
 * - /companies/{companyId}: Stores company information (currently read/write restricted to admins).
 * - /companies/{companyId}/clients/{clientId}: Stores client information for a specific company.
 * - /companies/{companyId}/origins/{originId}: Stores origin information for a specific company.
 * - /companies/{companyId}/clients/{clientId}/addresses/{addressId}: Stores addresses for a specific client.
 * - /companies/{companyId}/orders/{orderId}: Stores order information for a specific company.
 *
 * Key Security Decisions:
 * - User listing is disabled.
 * - Company-specific data access requires both company membership and a sufficient role.
 * - The rules rely on the existence of a user document under `/users/{userId}` with a valid `companyId` and `role`.
 *
 * Denormalization for Authorization:
 * - User's `companyId` and `role` are stored directly within the `/users/{userId}` document to avoid costly `get()` calls when authorizing access to company-specific data.
 */
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ---------- Utils ----------
    function isSignedIn() {
      return request.auth != null;
    }
    function userDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }
    function userCompanyId() {
      return isSignedIn() ? userDoc().data.companyId : null;
    }
    function userRole() {
      return isSignedIn() ? userDoc().data.role : null;
    }
    function isViewer() { return isSignedIn() && (userRole() == "viewer" || userRole() == "editor" || userRole() == "admin"); }
    function isEditor() { return isSignedIn() && (userRole() == "editor" || userRole() == "admin"); }
    function isAdmin()  { return isSignedIn() && (userRole() == "admin"); }
    function isCompanyMember(companyId) {
      return isSignedIn() && userCompanyId() == companyId;
    }

    /**
     * @description Manages user profile data, allowing users to read their own profile and admins to manage all profiles.
     * @path /users/{userId}
     * @allow (get) User with UID 'user123' reading their own profile.
     * @deny (get) User with UID 'user456' attempting to read profile of 'user123'.
     * @allow (create) User with UID 'user123' creating their own profile with valid data.
     * @deny (create) User with UID 'user123' creating their own profile with invalid data (missing 'displayName').
     * @principle Enforces document ownership for reads and writes, and validates basic user data.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && request.auth.uid == userId;
      allow list: if false;

      function baseUserValid() {
        return request.resource.data.keys().hasAll(["displayName", "email", "companyId", "role"]) &&
               request.resource.data.displayName is string &&
               request.resource.data.displayName.size() > 0 &&
               request.resource.data.email is string &&
               request.resource.data.email.size() > 0 &&
               request.resource.data.companyId is string &&
               request.resource.data.companyId.size() > 0 &&
               request.resource.data.role in ["viewer", "editor", "admin"];
      }

      allow create: if isSignedIn() && request.auth.uid == userId && baseUserValid();
      allow update: if isSignedIn() && request.auth.uid == userId && resource != null && baseUserValid();
      allow delete: if isSignedIn() && request.auth.uid == userId && resource != null;
    }

    /**
     * @description Manages company data, allowing only admins to create, update, and delete companies.
     * @path /companies/{companyId}
     * @allow (get) User with role 'viewer' in company 'company1' reading the company's data.
     * @deny (get) User not in company 'company1' attempting to read the company's data.
     * @allow (create) User with role 'admin' in company 'company1' creating a new company.
     * @deny (create) User with role 'editor' in company 'company1' attempting to create a new company.
     * @principle Restricts company management to company administrators.
     */
    match /companies/{companyId} {
      allow get: if isCompanyMember(companyId) && isViewer();
      allow list: if false;
      allow create, update, delete: if isCompanyMember(companyId) && isAdmin();
    }

    /**
     * @description Manages client data for a specific company, allowing viewers to read and editors to manage.
     * @path /companies/{companyId}/clients/{clientId}
     * @allow (get) User with role 'viewer' in company 'company1' reading a client's data.
     * @deny (get) User not in company 'company1' attempting to read a client's data.
     * @allow (create) User with role 'editor' in company 'company1' creating a new client with valid data.
     * @deny (create) User with role 'editor' in company 'company1' creating a new client with invalid data (missing 'nome').
     * @principle Enforces company membership and role-based access control for client data.
     */
    match /companies/{companyId}/clients/{clientId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor() && validClient();

      function validClient() {
        return request.resource.data.keys().hasAll(["nome", "telefone", "createdAt"]) &&
               request.resource.data.nome is string &&
               request.resource.data.nome.size() > 0 &&
               request.resource.data.telefone is string &&
               request.resource.data.telefone.size() > 0 &&
               request.resource.data.createdAt is string &&
               request.resource.data.createdAt.size() > 0;
      }
    }

    /**
     * @description Manages origin data for a specific company, allowing viewers to read and editors to manage.
     * @path /companies/{companyId}/origins/{originId}
     * @allow (get) User with role 'viewer' in company 'company1' reading an origin's data.
     * @deny (get) User not in company 'company1' attempting to read an origin's data.
     * @allow (create) User with role 'editor' in company 'company1' creating a new origin with valid data.
     * @deny (create) User with role 'editor' in company 'company1' creating a new origin with invalid data (missing 'name').
     * @principle Enforces company membership and role-based access control for origin data.
     */
    match /companies/{companyId}/origins/{originId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor() && validOrigin();

      function validOrigin() {
        return request.resource.data.keys().hasAll(["name", "address", "createdAt"]) &&
               request.resource.data.name is string &&
               request.resource.data.name.size() > 0 &&
               request.resource.data.address is string &&
               request.resource.data.address.size() > 0 &&
               request.resource.data.createdAt is string &&
               request.resource.data.createdAt.size() > 0;
      }
    }

     /**
     * @description Manages address data for a specific client, allowing viewers to read and editors to manage.
     * @path /companies/{companyId}/clients/{clientId}/addresses/{addressId}
     * @allow (get) User with role 'viewer' in company 'company1' reading an address's data.
     * @deny (get) User not in company 'company1' attempting to read an address's data.
     * @allow (create) User with role 'editor' in company 'company1' creating a new address with valid data.
     * @deny (create) User with role 'editor' in company 'company1' creating a new address with invalid data (missing 'label').
     * @principle Enforces company membership and role-based access control for client address data.
     */
    match /companies/{companyId}/clients/{clientId}/addresses/{addressId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor() && validAddress();

      function validAddress() {
        return request.resource.data.keys().hasAll(["label", "logradouro", "numero", "bairro", "cidade", "estado", "cep", "fullAddress"]) &&
               request.resource.data.label is string &&
               request.resource.data.label.size() > 0 &&
               request.resource.data.logradouro is string &&
               request.resource.data.logradouro.size() > 0 &&
               request.resource.data.numero is string &&
               request.resource.data.numero.size() > 0 &&
               request.resource.data.bairro is string &&
               request.resource.data.bairro.size() > 0 &&
               request.resource.data.cidade is string &&
               request.resource.data.cidade.size() > 0 &&
               request.resource.data.estado is string &&
               request.resource.data.estado.size() > 0 &&
               request.resource.data.cep is string &&
               request.resource.data.cep.size() > 0 &&
               request.resource.data.fullAddress is string &&
               request.resource.data.fullAddress.size() > 0;
      }
    }

    /**
     * @description Manages order data for a specific company, allowing viewers to read and editors to manage.
     * @path /companies/{companyId}/orders/{orderId}
     * @allow (get) User with role 'viewer' in company 'company1' reading an order's data.
     * @deny (get) User not in company 'company1' attempting to read an order's data.
     * @allow (create) User with role 'editor' in company 'company1' creating a new order with valid data.
     * @deny (create) User with role 'editor' in company 'company1' creating a new order with invalid data (missing 'codigoRastreio').
     * @principle Enforces company membership and role-based access control for order data.
     */
    match /companies/{companyId}/orders/{orderId} {
      allow get, list: if isCompanyMember(companyId) && isViewer();
      allow create, update, delete: if isCompanyMember(companyId) && isEditor() && validOrder();

      function validOrder() {
          return request.resource.data.keys().hasAll([
            "codigoRastreio",
            "nomeCliente",
            "telefone",
            "origem",
            "destino",
            "valorEntrega",
            "formaPagamento",
            "pago",
            "status",
            "timeline",
            "messages",
            "createdAt",
            "createdBy"
          ]) &&
          request.resource.data.codigoRastreio is string &&
          request.resource.data.codigoRastreio.size() > 0 &&
          request.resource.data.nomeCliente is string &&
          request.resource.data.nomeCliente.size() > 0 &&
          request.resource.data.telefone is string &&
          request.resource.data.telefone.size() > 0 &&
          request.resource.data.origem is string &&
          request.resource.data.origem.size() > 0 &&
          request.resource.data.destino is string &&
          request.resource.data.destino.size() > 0 &&
          request.resource.data.valorEntrega is number &&
          request.resource.data.formaPagamento in ["pix", "dinheiro", "cartao", "boleto", "link", "haver"] &&
          request.resource.data.pago is bool &&
          request.resource.data.status in ["PENDENTE", "EM_ROTA", "ENTREGUE", "CANCELADA"] &&
          request.resource.data.createdAt is string &&
          request.resource.data.createdBy is string;
      }
    }

    // ---------- Bloqueio padr√£o ----------
    match /{document=**} {
      allow read, write: if false;
    }
  }
}